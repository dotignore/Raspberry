




//  http://sandbox.mc.edu/~bennet/cs220/codeex/cl0_cc.html

#include <iostream>
#include <math.h>

using namespace std;

// Class to represent points.
class Point {
    
private:
    double xval, yval;
    
public:
    // Constructor uses default arguments to allow calling with zero, one,
    // or two values.
    Point(double x = 0.0, double y = 0.0) {
        xval = x;
        yval = y;
    }
    
    // Extractors.
    double x() { return xval; }
    double y() { return yval; }
    
    // Distance to another point.  Pythagorean thm.
    double dist(Point other) {
        double xd = xval - other.xval;
        double yd = yval - other.yval;
        return sqrt(xd*xd + yd*yd);
    }
    
    // Add or subtract two points.
    Point add(Point b)
    {
        return Point(xval + b.xval, yval + b.yval);
    }
    
    Point sub(Point b)                                                      //     d = b.sub(c);
    {
        return Point(xval - b.xval, yval - b.yval);
    }
    
    // Move the existing point.
    void move(double a, double b)
    {
        xval += a;
        yval += b;
    }
    
    // Print the point on the stream.  The class ostream is a base class
    // for output streams of various types.
    void print(ostream &strm)
    {
        strm << "(" << xval << "," << yval << ")";
    }
};

// Print a line of the form x op y = z, where x, y, and z are points.
void prline(ostream &strm, Point x, char *op, Point y, Point z)             //  prline(cout, b, "-", c, d);
{
    x.print(strm);
    cout << " " << op << " ";
    y.print(strm);
    cout << " = ";
    z.print(strm);
    cout << endl;
}

int main()
{
    // Some points.
    Point a(5.2, -4.8);
    Point b(3.0, 9.0);
    Point c(-3.38);
    Point d;
    
    // Some arith. on the points.
    d = b.sub(c);
    prline(cout, b, "-", c, d);                                 // (3,9) - (-3.38,0) = (6.38,9)
    prline(cout, a, "+", b, a.add(b));                          // (5.2,-4.8) + (3,9) = (8.2,4.2)
    a.print(cout); cout << " is " << a.dist(d) << " from "; d.print(cout);//(5.2,-4.8) is 13.8504 from (6.38,9)
    cout << endl;
    
    // Point variables are not references.
    Point fred[5];
    
    for(int m = 0; m < 5; m++) fred[m] = a;
    double w = 4.5;
    double x = -2.31;
    for(int m = 0; m < 5; m++) {
        fred[m].move(w, x);
        w += 3.4;
        x -= 1.3;
    }
    for(int m = 0; m < 5; m++) {
        fred[m].print(cout);                 //  (9.7,-7.11), (13.1,-8.41), (16.5,-9.71), (19.9,-11.01), (23.3,-12.31)
        cout << endl;
    }
}


/*

// ######### http://ustimov.org/posts/21/
#include <iostream>
using namespace std;

struct Klass {
	int size;
	double * data;
 
	Klass() {
		std::cout << "Конструктор по умолчанию" << std::endl;  //           Klass k1;
		size = 3;
		data = new double[size];
	}
 
	Klass(const Klass & klass) {                                //          Klass k2(k1);
		std::cout << "Конструктор копирования ";                //          Klass k3 = k2;
		size = klass.size;                                      //          Klass k4 = Klass(k3);
		data = new double[size];                                //          Klass * pKlass = new Klass(k4);
		for (int i = 0; i < size; i++) {
			data[i] = klass.data[i];
            std::cout << i << " ";
		}
	}
    
	Klass & operator=(const Klass & klass) {                   //       k1 = k2;
		if (this != &klass) {
			std::cout << "Перегруженный оператор присваивания ";
			delete[] data;
			size = klass.size;
			data = new double[size];
			for (int i = 0; i < size; i++) {
				data[i] = klass.data[i];
                std::cout << i << " ";
			}
		}
		else {                                                  //      k2 = k2;
			std::cout << "Самоприсваивание" << std::endl;
		}
		return *this;
	}
    
	~Klass() {
		std::cout << "Деструктор \t\t" << this << std::endl;
		delete[] data;
	}
};


int main() {
    
    cout << "======= Klass k1; =======" << endl;
	Klass k1;
    cout << endl;
    
    cout << "======= Klass k2(k1); =======" << endl;
	Klass k2(k1);
    cout << endl;
    
    cout << "======= Klass k3 = k2; =======" << endl;
	Klass k3 = k2;
    cout << endl;
    
    cout << "======= Klass k4 = Klass(k3); =======" << endl;
	Klass k4 = Klass(k3);
    cout << endl;
    
    cout << "======= Klass * pKlass = new Klass(k4); =======" << endl;
	Klass * pKlass = new Klass(k4);
    cout << endl;
    
    cout << "======= k1 = k2; =======" << endl;
	k1 = k2;
    cout << endl;
    
    cout << "======= k2 = k2; =======" << endl;
	k2 = k2;
    
    return 0;
}



// Конструктор по умолчанию
// Конструктор копирования
// 0 1 2 Конструктор копирования
// 0 1 2 Конструктор копирования
// 0 1 2 Конструктор копирования
// 0 1 2 Перегруженный оператор присваивания
// 0 1 2 Самоприсваивание
// Деструктор 		0x7fff5fbff880
// Деструктор 		0x7fff5fbff890
// Деструктор 		0x7fff5fbff8b0
// Деструктор 		0x7fff5fbff8c0
// Program ended with exit code: 0




// ##########################################################################################





 
 
 
 
 // http://cppstudio.com/post/9903/
 #include <iostream>
 using namespace std;
 
 class SomeClass{
 int *ptr; // указатель на какой-либо участок памяти
 public:
 
 SomeClass(){                        // Конструктор по умолчанию    SomeClass obj1;
 cout << "\nОбычный конструктор \t\t" << this << endl;
 }
 
 SomeClass(const SomeClass &obj){    // Конструктор копирования            funcShow(obj1);
 cout << "\nКонструктор копирования \t\t" << this << endl;
 }
 
 ~SomeClass(){
 cout << "Дестркуктор \t\t" << this << endl;
 }
 };
 
 void funcShow(SomeClass object){        //                              funcShow(obj1);
 cout << "\nФункция принимает объект, как параметр\n";
 }
 
 SomeClass funcReturnObject(){
 SomeClass object;
 cout <<   "\nФункция возвращает объект\n";
 return object;
 }
 
 int main()
 {
 cout << "1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
 SomeClass obj1; // создаем объект класса
 cout << "1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
 
 cout << "2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
 funcShow(obj1); // передаем объект в функцию
 cout << "2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
 
 cout << "3 - 4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
 funcReturnObject(); // эта функция возвращает объект
 cout << "3 - 4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n";
 
 cout << "5 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
 SomeClass obj2 = obj1;  // инициализация объекта при создании
 cout << "5 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
 
 }
 
 
 // 1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Обычный конструктор 		0x7fff5fbff8c8
 // 1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 // 2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Конструктор копирования 		0x7fff5fbff8b0
 // Функция принимает объект, как параметр
 // Дестркуктор 		0x7fff5fbff8b0
 // 2 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 // 3 - 4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Обычный конструктор 		0x7fff5fbff8a8
 // Функция возвращает объект
 // Дестркуктор 		0x7fff5fbff8a8
 // 3 - 4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 // 5 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 // Конструктор копирования 		0x7fff5fbff8a0
 // 5 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 // Дестркуктор 		0x7fff5fbff8a0
 // Дестркуктор 		0x7fff5fbff8c8
 // Program ended with exit code: 0
 
 
 
 // ##########################################################################################
 
 #include <iostream>
 using namespace std;
 
 class Base{
 public:
 explicit Base(int i) : num(i) {         // Base d1(5);
 cout << "\t\t\tBase(int)" << endl;
 }          // 5
 
 explicit Base(char c) : letter(c) {     // Base d2('c');
 cout << "\t\t\tBase(char)" << endl;
 }       // c
 
 Base(const Base& other) {               // Base d3 = d2;
 cout << "\t\t\tBase(Base&)" << endl;
 }
 
 Base() {
 cout << "\t\t\tBase()" << endl;
 }
 
 private:
 int num;
 char letter;
 
 };
 
 //Base FunctionBase(Base theCat){
 //    return theCat;
 //}
 
 int main(){
 cout << "Derived d1(5) calls: ";
 Base d1(5);                          // explicit Base(int i) : num(i) { cout << "Base(int)" << endl; }
 cout << "Derived d1('c') calls: ";
 Base d2('c');                        // explicit Base(char c) : letter(c) { cout << "Base(char)" << endl; }
 cout << "Derived d3 = d2 calls: " ;
 Base d3 = d2;
 cout << "Derived d4 calls: ";
 Base d4;
 
 //FunctionBase(d1);
 
 return 0;
 }
 
 
 // Derived d1(5) calls: 			Base(int)
 // Derived d1('c') calls: 			Base(char)
 // Derived d3 = d2 calls: 			Base(Base&)
 // Derived d4 calls: 			Base()
 // Program ended with exit code: 0
 
 
 
 
 // ##########################################################################################
 
 
 



#include <iostream>
using namespace std;

class ClassName{
public:
    ClassName(){cout << "classname_constructor" << endl;}
    ClassName(const ClassName &obj);
    ~ClassName();
};


ClassName::ClassName(const ClassName &obj){
    cout << "copy_object" << endl;
}

ClassName::~ClassName(){
    cout << "~classname_destructor" << endl;
}

ClassName FUNKTION(ClassName tje){
    cout << "return tje;" << endl;
    return tje;
}

int main(){
    ClassName cname;
    ClassName cname1 = cname;
    return 0;
}


// classname_constructor
// copy_object
// ~classname_destructor
// ~classname_destructor
// Program ended with exit code: 0

*/